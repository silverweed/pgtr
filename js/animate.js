// Generated by IcedCoffeeScript 108.0.11

/*
	Functions used for rendering the scene
 */

(function() {
  'use strict';
  var renderLoop, updateRipples, updateRipplesTimer;

  renderLoop = function(world) {
    var animate, player;
    player = world.entities.player();
    animate = function() {
      var delta, _ref;
      world.stats.begin();
      requestAnimationFrame(animate);
      delta = world.clock.getDelta();
      if (delta > 1 / 10.0) {
        delta = 1 / 30.0;
      }
      player.update(delta);
      world.debug.forEach(function(e) {
        return ((e != null ? e.update : void 0) != null) && e.update(delta);
      });
      player.plane.material.uniforms.time.value += delta;
      updateRipples(player, delta);
      world.updateBuoyancy(delta);
      if (world.physics.enabled) {
        world.physics.step(delta, CONF.PHYSICS.SUBSTEPS, CONF.PHYSICS.FIXED_TIME_STEP);
      }
      if ((_ref = world.postprocess) != null ? _ref.enabled : void 0) {
        world.postprocess.composer.render(world.scene, world.camera);
      } else {
        world.renderer.render(world.scene, world.camera);
      }
      return world.stats.end();
    };
    animate();
    return null;
  };

  updateRipplesTimer = 0;

  updateRipples = function(player, delta) {
    updateRipplesTimer += delta;
    player.planeWater.tickRippleTimes(delta);
    if (updateRipplesTimer > CONF.OCEAN.RIPPLES.UPDATE_DELAY) {
      updateRipplesTimer = 0;
      return player.planeWater.pushRippleSrc(player.position);
    }
  };

  window.renderLoop = renderLoop;

}).call(this);
