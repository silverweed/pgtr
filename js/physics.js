// Generated by IcedCoffeeScript 108.0.11

/*
	Interface to Ammo.js for physics simulation
 */

(function() {
  'use strict';
  var Physics,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Physics = (function() {
    function Physics() {
      this.broadphase = new Ammo.btDbvtBroadphase();
      this.collConf = new Ammo.btDefaultCollisionConfiguration();
      this.dispatcher = new Ammo.btCollisionDispatcher(this.collConf);
      this.solver = new Ammo.btSequentialImpulseConstraintSolver();
      this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.broadphase, this.solver, this.collConf);
      this.dynamicsWorld.setGravity(new Ammo.btVector3(0, CONF.PHYSICS.GRAVITY, 0));
      this.bodies = [];
      this.enabled = true;
    }

    Physics.prototype.createGround = function() {
      var groundMotionState, groundRigidBody, groundRigidBodyCI, groundShape;
      groundShape = new Ammo.btStaticPlaneShape(new Ammo.btVector3(0, 1, 0), 1);
      groundMotionState = new Ammo.btDefaultMotionState(new Ammo.btTransform(new Ammo.btQuaternion(0, 0, 0, 1), new Ammo.btVector3(0, -1.8, 0)));
      groundRigidBodyCI = new Ammo.btRigidBodyConstructionInfo(0, groundMotionState, groundShape, new Ammo.btVector3(0, 0, 0));
      groundRigidBody = new Ammo.btRigidBody(groundRigidBodyCI);
      this.dynamicsWorld.addRigidBody(groundRigidBody);
      return this;
    };

    Physics.prototype.addRigidBody = function(threeObj, opts) {
      var inertia, mass, motionState, pos, rb, rbCI, shape, _ref;
      shape = (function() {
        switch (opts != null ? opts.collisionShape : void 0) {
          case 'btBoxShape':
            return new Ammo.btBoxShape(new Ammo.btVector3(threeObj.scale.x / 2, threeObj.scale.y / 2, threeObj.scale.z / 2));
          case 'btSphereShape':
          case void 0:
            return new Ammo.btSphereShape(threeObj.scale.x);
          default:
            return new Ammo[opts.collisionShape](opts.collisionShapeArgs);
        }
      })();
      pos = threeObj.position;
      motionState = new Ammo.btDefaultMotionState(new Ammo.btTransform(new Ammo.btQuaternion(0, 0, 0, 1), new Ammo.btVector3(pos.x, pos.y, pos.z)));
      mass = (opts != null ? opts["static"] : void 0) ? 0 : (_ref = opts != null ? opts.mass : void 0) != null ? _ref : 1;
      inertia = new Ammo.btVector3(0, 0, 0);
      shape.calculateLocalInertia(mass, inertia);
      rbCI = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, inertia);
      rb = new Ammo.btRigidBody(rbCI);
      if (opts != null ? opts["static"] : void 0) {
        rb.setCollisionFlags(Ammo.CF_STATIC_OBJECT);
      } else {
        rb.setDamping(CONF.PHYSICS.DFLT_LIN_DAMP, CONF.PHYSICS.DFLT_ANG_DAMP);
        if ((opts != null ? opts.lockedAxes : void 0) != null) {
          rb.setAngularFactor(new Ammo.btVector3(__indexOf.call(opts.lockedAxes, 'x') >= 0 ? 0 : 1, __indexOf.call(opts.lockedAxes, 'y') >= 0 ? 0 : 1, __indexOf.call(opts.lockedAxes, 'z') >= 0 ? 0 : 1));
        }
      }
      threeObj.rigidbody = rb;
      this.dynamicsWorld.addRigidBody(rb);
      this.bodies.push([rb, threeObj]);
      l("Adding " + threeObj + " to physics world. Phys world size = " + this.bodies.length);
      return this;
    };

    Physics.prototype.step = function(timeStep, subdivisions, fixedTimeStep) {
      if (subdivisions == null) {
        subdivisions = 1;
      }
      if (fixedTimeStep == null) {
        fixedTimeStep = 1 / 60.0;
      }
      if (timeStep >= subdivisions * fixedTimeStep) {
        console.warn("timeStep >= subdivisions * fixedTimeStep " + ("(" + timeStep + " >= " + subdivisions + " * " + fixedTimeStep + " ") + ("(= " + (subdivisions * fixedTimeStep) + ")): ") + "simulation is losing time!");
      }
      this.dynamicsWorld.stepSimulation(timeStep, subdivisions, fixedTimeStep);
      this.bodies.forEach(function(_arg) {
        var body, obj, origin, rot, transform;
        body = _arg[0], obj = _arg[1];
        transform = new Ammo.btTransform();
        body.getMotionState().getWorldTransform(transform);
        origin = transform.getOrigin();
        rot = transform.getRotation();
        obj.position.set(origin.x(), origin.y(), origin.z());
        return obj.quaternion.set(rot.x(), rot.y(), rot.z(), rot.w());
      });
      return this;
    };

    return Physics;

  })();

  window.Physics = Physics;

}).call(this);
